/**
 * @file TaskReciever
 * @author Jim Bulkowski <jim.b@paperelectron.com>
 * @project taskrunner
 * @license MIT {@link http://opensource.org/licenses/MIT}
 */

import {CreatePlugin} from "@pomegranate/plugin-tools";
import {map, each, get, isFunction, fromPairs, merge, getOr, set} from 'lodash/fp'
import {ActionTree, PGStore, Task, PgMigrationTemplate} from 'actiontrees'

const tsActionGenerator = `// Generated by the Pomegranate cli on {{creationDate}}

// Action: {{name}}

import {Task} from 'actiontrees'

export const Action = (PluginLogger): Task => {
  return {
    config: {
      name: '{{name}}',
      initial: '{{transition}}',
      // Internal default values below.
      //retryOnError: true,
      //retryDelay: 1000,
      //delayMultiplier: 1.5,
      //retryLimit: 1,
      //abstractHandlers: []
    },
    /* 
     * transitions prop can be populated here, additionally Pom will 
     * autoload and merge with functions from ./transitions
     */
    transitions: {} 
  }
}
`

const tsTransitionGenerator = `// Generated by the Pomegranate cli on {{creationDate}}

// Action: {{name}}
// Transition: {{transition}}

export const Transition = (PluginLogger) => {
  return (State, taskController) => {
    return [{to: 'done'}, State]
  }
}

`

const tsAbstractGenerator = `// Generated by the Pomegranate cli on {{creationDate}}

// AbstractTransition: {{name}}

export const Abstract = (PluginLogger) => {
  return (State, taskController) => {
    return [{to: 'done'}, State]
  }
}
`

export const ActionTrees = CreatePlugin('anything')
  .configuration({
    name: 'ActionTree',
    injectableParam: 'ActionTree',
    depends: ['@pomofficial/RabbitMQ', '@pomofficial/KnexDAO']
  })

  .variables({
    infoLogging: false,
    debugLogging: false,
    tablePrefix: 'actiontree'
  })
  .directories(['actions', 'abstract'])
  .hooks({
    load: async (Injector, PluginVariables, PluginFiles, PluginLogger, Knex, SQL, RabbitMQ) => {
      let storage = new PGStore(Knex, PluginVariables.tablePrefix)

      let Trees = new ActionTree(storage, {
        debugLogging: PluginVariables.debugLogging,
        infoLogging: PluginVariables.infoLogging,
        logger: PluginLogger
      })

      let abstractTransitions = await PluginFiles('abstract').fileList({ext: '.js'})
      let actionDirs = await PluginFiles('actions').fileList({directories: true})


      let buildTransitions = map((dirPath: {path: string, filename: string; getBaseName: () => string}) => {
        let required = require(dirPath.path)
        let fileName = dirPath.filename
        let baseName = dirPath.getBaseName()
        let M = get('Transition', required)
        if (!M) {
          throw new Error(`Action/transitions/${fileName} does not contain an export on the Transition property.`)
        }
        if (!isFunction(M)) {
          throw new Error(`Action/transitions/${fileName} does not export an injectable function on the Transition property.`)
        }

        let injected = Injector.inject(M)
        return [baseName, injected]
      })

      let findTransitions = async (dirPath: {path: string, filename: string; getBaseName: () => string}) => {
        let transitionDir = PluginFiles('actions').join(dirPath.path, 'transitions')
        let findTransitions = PluginFiles('actions').ctors.fileList(transitionDir)
        let transitions = await findTransitions({ext: '.js'})
        return fromPairs(buildTransitions(transitions))
      }

      each(([name, abstractTransition]) => {
        Trees.registerAbstract(name, abstractTransition)
      }, map((dirPath) => {
        let required = require(dirPath.path)
        let fileName = dirPath.getBaseName()
        PluginLogger.log(`Found Abstract Transition : ${fileName}.`, 2)
        let M = get('Abstract', required)
        if (!M) {
          throw new Error(`${fileName} does not contain an export on the Abstract property.`)
        }
        if (!isFunction(M)) {
          throw new Error(`${fileName} does not export an injectable function on the Abstract property.`)
        }
        return [fileName, Injector.inject(M)]
      }, abstractTransitions))


      each(async (task: Promise<Task>) => {
        let t = await task
        Trees.registerTask(t)
      }, map(async (dirPath): Promise<Task> => {

        let required = require(dirPath.path)
        let fileName = dirPath.filename
        PluginLogger.log(`Found Task Directory: ${fileName}.`, 2)
        let M = get('Action', required)
        if (!M) {
          throw new Error(`Action/index ${fileName} does not contain an export on the Action property.`)
        }
        if (!isFunction(M)) {
          throw new Error(`Action/index ${fileName} does not export an injectable function on the Action property.`)
        }
        let action = Injector.inject(M)
        let transitions = await findTransitions(dirPath)
        let allTransitions = merge(transitions,getOr({}, 'transitions', action))
        return set('transitions', allTransitions, action)

      }, actionDirs))


      return Trees
    }
  })

  .commands((PomConfig, PluginVariables, PluginFiles, PluginPickDirectory, Handlebars) => {
    return (yargs) => {
      return yargs
        .usage('usage: $0')
        .command({
          command: 'generate',
          aliases: 'g',
          describe: 'Generates ActionTree resources',
          builder: (yargs) => {
            return yargs
              .command({
                command: 'action <name> <transition>',
                aliases: 'a',
                describe: `Generates Action directory and files at <name> with <transition> transition. 
                If the <action> doesnt exists, <transition> will be added as its inititial transition.  
                `,
                builder: (yargs) => {
                  return yargs
                    .positional('name', {
                      describe: 'The name of the Action to create, or add to.',
                      type: 'string'
                    })
                    .positional('transition', {
                      describe: 'The name of the transition to create',
                      type: 'string'
                    })
                },
                handler: async (argv) => {
                  let Pf = PluginFiles('actions')
                  let indexPath = Pf.join(argv.name, 'index.ts')
                  let transitionPath = Pf.join(argv.name, 'transitions',`${argv.transition}.ts`)
                  let actionExists = await Pf.projectFileExists(indexPath)
                  let transitionExists = await Pf.projectFileExists(transitionPath)

                  if(!actionExists && !argv.force){
                    let compileAction = Handlebars.compile(tsActionGenerator)
                    let compiledAction = compileAction({
                      creationDate: new Date().toDateString(),
                      name: argv.name,
                      transition: argv.transition
                    })
                    await Pf.outputProjectFile(indexPath, compiledAction)
                    console.log(`Created @actionforest/ActionTree at ${indexPath}`)
                  }

                  if(!transitionExists){
                    let compileTransition = Handlebars.compile(tsTransitionGenerator)
                    let compiledTransition = compileTransition({
                      creationDate: new Date().toDateString(),
                      name: argv.name,
                      transition: argv.transition
                    })
                    await Pf.outputProjectFile(transitionPath, compiledTransition)
                    console.log(`Created @actionforest/ActionTree Transition ${argv.transition} at ${transitionPath}`)
                    return
                  } else {
                    console.log(`ActionTree ${argv.name}, Transition ${argv.transition} at ${transitionPath} already exists`)
                  }
                }
              })
              .command({
                command: 'abstract <name>',
                aliases: 'abs',
                describe: `Generates abstract handler <name>.`,
                builder: (yargs) => {
                  return yargs
                    .positional('name', {
                      describe: 'The name of the abstract handler to create',
                      type: 'string'
                    })
                    .option('force', {
                      alias: 'f',
                      default: false,
                      describe: 'overwrites the specified file if it exists.',
                      type: 'boolean'
                    })
                },
                handler: async (argv) => {
                  let Pf = PluginFiles('abstract')

                  let abstractPath = Pf.join(`${argv.name}.ts`)

                  let abstractExists = await Pf.projectFileExists(abstractPath)

                  if(abstractExists && !argv.force){
                    throw new Error(`${abstractPath} \nexists, \nrerun with -f to overwrite.`)
                  }
                  let compileAbstract = Handlebars.compile(tsAbstractGenerator)
                  let compiledAbstract = compileAbstract({
                    creationDate: new Date().toDateString(),
                    name: argv.name,
                  })

                  await Pf.outputProjectFile(abstractPath, compiledAbstract)
                  console.log(`Created @actionforest/ActionTree Transition ${argv.name} at ${abstractPath}`)
                }
              })
              .command({
                command: 'migrations <type>',
                aliases: 'm',
                describe: `Generates Knex migration files.`,
                builder: (yargs) => {
                  return yargs
                    .positional('type', {
                      describe: 'The database type to generate migrations for.',
                      type: 'string'
                    })
                    .option('force', {
                      alias: 'f',
                      default: false,
                      describe: 'overwrites the specified file if it exists.',
                      type: 'boolean'
                    })
                },
                handler: async (argv) => {
                  let prefix = PluginVariables.tablePrefix
                  let MigrationTmplt = PgMigrationTemplate(prefix)
                  let compileTmplt = Handlebars.compile(MigrationTmplt)
                  let compiledMigration = compileTmplt({tablePrefix: prefix})
                  let filename = `${prefix}_cli_migration.js`
                  return PluginPickDirectory('@pomofficial/KnexClient', 'migrations')
                    .outputProjectFile(filename, compiledMigration)
                    .then((result) => {
                      console.log(`${filename} migration file created
                      Run 
                      pom p @pomofficial/knexclient migrate latest
                      to apply it
                      `)
                    })
                }
              })
              .help()
          },
          handler: () => {
            yargs.showHelp()
          }

        })
        .help()
    }
  })
